/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    app_netxduo.c
  * @author  MCD Application Team
  * @brief   NetXDuo applicative file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2020-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "app_netxduo.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "nx_crypto.h"
#include "nx_secure_tls_api.h"
#include "nx_secure_x509.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

typedef struct{
	UINT sCount,
	     fCount,
			 upTime;
	TX_THREAD AppMainThread,
			  UnnamedThread;
	TX_SEMAPHORE Semaphore;
	NX_PACKET_POOL EthPool,WebServerPool;
	ULONG IpAddress,NetMask,free_bytes;
	NX_IP IpInstance;
	NX_DHCP DHCPClient;
	NX_WEB_HTTP_SERVER HTTPServer;
	NX_TCP_SOCKET TCPSocket;
	CHAR *pointer;
} nx_t;

nx_t nx;
FX_MEDIA ram_disk; //fake ram disk

extern const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers; //Include cryptographic routines for TLS.
//extern const USHORT nx_crypto_ecc_supported_groups[];
//extern const NX_CRYPTO_METHOD *nx_crypto_ecc_curves[];
//extern const UINT nx_crypto_ecc_supported_groups_size;

//Define TLS data for HTTPS.
CHAR crypto_metadata[12000 * NX_WEB_HTTP_SERVER_SESSION_MAX]; //10128
UCHAR tls_packet_buffer[18000];

//NX_WEB_HTTP_SERVER_SESSION_MAX defaults to 2 in nx_web_http_server.h
UCHAR server_tls_packet_buffer[18000 * NX_WEB_HTTP_SERVER_SESSION_MAX];

//Define certificate containers. The server certificate is used to identify the NetX
//Web HTTPS server
NX_SECURE_X509_CERT server_certificate;

//Certificate information for server and client (see NetX Secure TLS reference on X.509
// certificates for more information). Arrays are populated with binary versions Of
// certificates and keys and the corresponding “len�? variables are assigned the lengths
// of that data. Trusted certificates do not need a private key.
UCHAR server_cert_der[] = {
	0x30, 0x82, 0x03, 0xd2, 0x30, 0x82, 0x02, 0xba, 0xa0, 0x03, 0x02, 0x01,
	0x02, 0x02, 0x01, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
	0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x7a, 0x31, 0x0b, 0x30,
	0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x43, 0x41, 0x31,
	0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x09, 0x53, 0x61,
	0x6e, 0x20, 0x44, 0x69, 0x65, 0x67, 0x6f, 0x31, 0x16, 0x30, 0x14, 0x06,
	0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0d, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73,
	0x73, 0x20, 0x4c, 0x6f, 0x67, 0x69, 0x63, 0x31, 0x14, 0x30, 0x12, 0x06,
	0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0b, 0x4e, 0x65, 0x74, 0x58, 0x20, 0x53,
	0x65, 0x63, 0x75, 0x72, 0x65, 0x31, 0x1c, 0x30, 0x1a, 0x06, 0x03, 0x55,
	0x04, 0x03, 0x0c, 0x13, 0x4e, 0x65, 0x74, 0x58, 0x20, 0x53, 0x65, 0x63,
	0x75, 0x72, 0x65, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x41, 0x30,
	0x1e, 0x17, 0x0d, 0x31, 0x36, 0x31, 0x31, 0x31, 0x31, 0x31, 0x39, 0x35,
	0x31, 0x30, 0x30, 0x5a, 0x17, 0x0d, 0x32, 0x36, 0x31, 0x31, 0x30, 0x39,
	0x31, 0x39, 0x35, 0x31, 0x30, 0x30, 0x5a, 0x30, 0x62, 0x31, 0x0b, 0x30,
	0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x43, 0x41, 0x31,
	0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0d, 0x45, 0x78,
	0x70, 0x72, 0x65, 0x73, 0x73, 0x20, 0x4c, 0x6f, 0x67, 0x69, 0x63, 0x31,
	0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0b, 0x4e, 0x65,
	0x74, 0x58, 0x20, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x31, 0x18, 0x30,
	0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0f, 0x77, 0x77, 0x77, 0x2e,
	0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30,
	0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
	0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30,
	0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xae, 0x03, 0x2c, 0xec,
	0xa2, 0x79, 0xd1, 0x15, 0x20, 0x88, 0x4d, 0xcd, 0xa2, 0x1b, 0x05, 0xe3,
	0xbd, 0x55, 0xad, 0xc6, 0x1f, 0x64, 0xe8, 0xb5, 0xc5, 0x0d, 0x67, 0xfc,
	0x7e, 0xda, 0xfb, 0x70, 0xf6, 0xc9, 0x47, 0x87, 0x3a, 0xaa, 0x88, 0x00,
	0xf1, 0xa7, 0xf7, 0xe1, 0xf5, 0x2c, 0x54, 0x0e, 0x33, 0xda, 0xbe, 0x9c,
	0x66, 0x30, 0xd9, 0x40, 0xeb, 0x1d, 0xce, 0xe1, 0x55, 0x15, 0x2b, 0x11,
	0x47, 0x6c, 0x7e, 0x88, 0xc6, 0x24, 0xcf, 0x87, 0x1b, 0xb5, 0x1f, 0x47,
	0xb9, 0xef, 0xad, 0x29, 0xd3, 0x2e, 0x43, 0xee, 0x39, 0xdd, 0x09, 0x54,
	0xba, 0xfc, 0xed, 0xbc, 0x2e, 0x0e, 0x53, 0x15, 0x37, 0xcb, 0xc5, 0xf5,
	0xee, 0x70, 0x2a, 0xe8, 0x01, 0x6d, 0xb1, 0x39, 0x94, 0x5a, 0xc2, 0x8a,
	0x00, 0x04, 0xa9, 0xff, 0xea, 0x56, 0xf7, 0xd7, 0xa8, 0x1b, 0xa4, 0x26,
	0xcd, 0x28, 0xaf, 0xfa, 0x52, 0x85, 0x1c, 0x26, 0x3e, 0x5e, 0x01, 0xf7,
	0xe1, 0x66, 0xff, 0xac, 0xad, 0x9c, 0x98, 0x2f, 0xe0, 0x7e, 0x9f, 0xf1,
	0x33, 0x31, 0xc3, 0x7f, 0xe6, 0x58, 0x5d, 0xd8, 0x5f, 0x7d, 0x2b, 0x5a,
	0x55, 0xcf, 0xb1, 0x91, 0x53, 0x41, 0x04, 0xac, 0x86, 0x5e, 0x01, 0x35,
	0x2b, 0x74, 0x8d, 0x46, 0x4d, 0x48, 0xc0, 0x5f, 0x83, 0x67, 0xb5, 0x6d,
	0x52, 0x3f, 0x3e, 0xe6, 0xec, 0xf8, 0x2e, 0x10, 0x28, 0xdb, 0x69, 0xa6,
	0x9d, 0x4b, 0xde, 0x19, 0x2e, 0xd2, 0x5f, 0xc8, 0xa9, 0x3b, 0x52, 0xe9,
	0xb2, 0xcd, 0x6e, 0x19, 0x22, 0xf9, 0x99, 0xa6, 0xcc, 0xf5, 0xd3, 0xec,
	0xff, 0x0c, 0x77, 0x6f, 0x25, 0x92, 0x07, 0x4c, 0x64, 0x7d, 0x34, 0x49,
	0x6f, 0xff, 0x0a, 0xa8, 0x15, 0x64, 0x72, 0x2d, 0x4f, 0x42, 0x05, 0xe8,
	0x2b, 0x01, 0xf1, 0xe3, 0x65, 0x94, 0x23, 0xd9, 0xdf, 0x5e, 0x3b, 0xb5,
	0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x7b, 0x30, 0x79, 0x30, 0x09, 0x06,
	0x03, 0x55, 0x1d, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x2c, 0x06, 0x09,
	0x60, 0x86, 0x48, 0x01, 0x86, 0xf8, 0x42, 0x01, 0x0d, 0x04, 0x1f, 0x16,
	0x1d, 0x4f, 0x70, 0x65, 0x6e, 0x53, 0x53, 0x4c, 0x20, 0x47, 0x65, 0x6e,
	0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69,
	0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d,
	0x0e, 0x04, 0x16, 0x04, 0x14, 0x8d, 0xb0, 0xee, 0x8f, 0x6b, 0x43, 0x52,
	0x29, 0xf4, 0x25, 0xff, 0x3c, 0xda, 0x5f, 0xb3, 0xce, 0x9b, 0x7b, 0x75,
	0xe1, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16,
	0x80, 0x14, 0x1b, 0x8d, 0x06, 0xd9, 0x6b, 0xad, 0xee, 0x82, 0x24, 0x26,
	0x55, 0x9a, 0x1b, 0x03, 0x44, 0x92, 0x0a, 0x06, 0x92, 0x48, 0x30, 0x0d,
	0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05,
	0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x75, 0x83, 0x89, 0xab, 0x84, 0x52,
	0x5f, 0xa4, 0x9e, 0x98, 0xca, 0xa3, 0xf9, 0xab, 0xd4, 0x04, 0x32, 0xa4,
	0x8c, 0x96, 0x90, 0x39, 0x88, 0x92, 0xc3, 0xcd, 0x51, 0xc3, 0x01, 0x35,
	0x03, 0x78, 0xfa, 0x0d, 0x1e, 0x7b, 0x79, 0xe9, 0x7d, 0xd8, 0x68, 0x7a,
	0x65, 0xc6, 0x00, 0x7c, 0xa1, 0x7a, 0x52, 0xc9, 0xa3, 0xf4, 0x0b, 0xbd,
	0x76, 0x24, 0xdf, 0xde, 0x22, 0x2d, 0x95, 0xc5, 0xb6, 0x54, 0xb1, 0xac,
	0xb6, 0x9a, 0xe4, 0x68, 0x0f, 0x97, 0x4a, 0x44, 0xa2, 0x87, 0x01, 0x82,
	0xd4, 0x25, 0xbd, 0x01, 0xbc, 0x35, 0x8a, 0x6d, 0xb7, 0x7c, 0x48, 0xaa,
	0x92, 0xd7, 0x57, 0x76, 0x6a, 0xb0, 0xc9, 0x46, 0xa6, 0xbe, 0xbf, 0x0f,
	0xf0, 0xea, 0x62, 0x57, 0x71, 0x42, 0xf6, 0x67, 0xa7, 0xa1, 0x50, 0x87,
	0x14, 0x8e, 0x32, 0xd0, 0x5e, 0xc9, 0x7b, 0x79, 0x7e, 0xfa, 0x17, 0xc7,
	0xad, 0xbd, 0xc3, 0x98, 0x79, 0x45, 0xfb, 0x7f, 0xf7, 0xe6, 0x9f, 0x77,
	0xb3, 0x44, 0xc3, 0xaf, 0x6b, 0x61, 0x6a, 0x04, 0x68, 0x24, 0x2d, 0x31,
	0xf1, 0x28, 0x2c, 0xf4, 0xf0, 0x07, 0xfe, 0xfd, 0x66, 0x98, 0x77, 0x37,
	0x7b, 0x80, 0x1f, 0xb2, 0x49, 0xe4, 0xa6, 0x24, 0x72, 0x42, 0xf4, 0xca,
	0x91, 0x80, 0xa1, 0xb2, 0x0a, 0xc9, 0xc0, 0x93, 0xa7, 0x22, 0x0b, 0x13,
	0x8a, 0xb2, 0x75, 0x4b, 0x66, 0xf9, 0x87, 0x3a, 0x51, 0x97, 0xc7, 0x1e,
	0x2b, 0x61, 0x81, 0x5c, 0xf0, 0xf8, 0x4c, 0xdb, 0x36, 0xc7, 0xba, 0x49,
	0xd9, 0x04, 0x6a, 0x95, 0xb0, 0x7f, 0xfc, 0xce, 0xca, 0x23, 0xad, 0xf9,
	0xaf, 0x8a, 0x72, 0x8e, 0xab, 0xb8, 0x8b, 0x7e, 0xf7, 0x39, 0xa6, 0x22,
	0x56, 0x03, 0x72, 0x06, 0xc3, 0x57, 0x1f, 0x32, 0xaa, 0xb5, 0xa6, 0x00,
	0x67, 0x88, 0x4b, 0x40, 0xe9, 0x5e, 0x4a, 0x6f, 0x76, 0xe8
};
const UINT  server_cert_der_len = 982;

const UCHAR server_cert_key_der[] = {
	0x30, 0x82, 0x04, 0xa4, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00,
	0xae, 0x03, 0x2c, 0xec, 0xa2, 0x79, 0xd1, 0x15, 0x20, 0x88, 0x4d, 0xcd,
	0xa2, 0x1b, 0x05, 0xe3, 0xbd, 0x55, 0xad, 0xc6, 0x1f, 0x64, 0xe8, 0xb5,
	0xc5, 0x0d, 0x67, 0xfc, 0x7e, 0xda, 0xfb, 0x70, 0xf6, 0xc9, 0x47, 0x87,
	0x3a, 0xaa, 0x88, 0x00, 0xf1, 0xa7, 0xf7, 0xe1, 0xf5, 0x2c, 0x54, 0x0e,
	0x33, 0xda, 0xbe, 0x9c, 0x66, 0x30, 0xd9, 0x40, 0xeb, 0x1d, 0xce, 0xe1,
	0x55, 0x15, 0x2b, 0x11, 0x47, 0x6c, 0x7e, 0x88, 0xc6, 0x24, 0xcf, 0x87,
	0x1b, 0xb5, 0x1f, 0x47, 0xb9, 0xef, 0xad, 0x29, 0xd3, 0x2e, 0x43, 0xee,
	0x39, 0xdd, 0x09, 0x54, 0xba, 0xfc, 0xed, 0xbc, 0x2e, 0x0e, 0x53, 0x15,
	0x37, 0xcb, 0xc5, 0xf5, 0xee, 0x70, 0x2a, 0xe8, 0x01, 0x6d, 0xb1, 0x39,
	0x94, 0x5a, 0xc2, 0x8a, 0x00, 0x04, 0xa9, 0xff, 0xea, 0x56, 0xf7, 0xd7,
	0xa8, 0x1b, 0xa4, 0x26, 0xcd, 0x28, 0xaf, 0xfa, 0x52, 0x85, 0x1c, 0x26,
	0x3e, 0x5e, 0x01, 0xf7, 0xe1, 0x66, 0xff, 0xac, 0xad, 0x9c, 0x98, 0x2f,
	0xe0, 0x7e, 0x9f, 0xf1, 0x33, 0x31, 0xc3, 0x7f, 0xe6, 0x58, 0x5d, 0xd8,
	0x5f, 0x7d, 0x2b, 0x5a, 0x55, 0xcf, 0xb1, 0x91, 0x53, 0x41, 0x04, 0xac,
	0x86, 0x5e, 0x01, 0x35, 0x2b, 0x74, 0x8d, 0x46, 0x4d, 0x48, 0xc0, 0x5f,
	0x83, 0x67, 0xb5, 0x6d, 0x52, 0x3f, 0x3e, 0xe6, 0xec, 0xf8, 0x2e, 0x10,
	0x28, 0xdb, 0x69, 0xa6, 0x9d, 0x4b, 0xde, 0x19, 0x2e, 0xd2, 0x5f, 0xc8,
	0xa9, 0x3b, 0x52, 0xe9, 0xb2, 0xcd, 0x6e, 0x19, 0x22, 0xf9, 0x99, 0xa6,
	0xcc, 0xf5, 0xd3, 0xec, 0xff, 0x0c, 0x77, 0x6f, 0x25, 0x92, 0x07, 0x4c,
	0x64, 0x7d, 0x34, 0x49, 0x6f, 0xff, 0x0a, 0xa8, 0x15, 0x64, 0x72, 0x2d,
	0x4f, 0x42, 0x05, 0xe8, 0x2b, 0x01, 0xf1, 0xe3, 0x65, 0x94, 0x23, 0xd9,
	0xdf, 0x5e, 0x3b, 0xb5, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01,
	0x01, 0x00, 0xa5, 0x22, 0x2c, 0x52, 0xd0, 0x09, 0x4c, 0x4a, 0x81, 0x59,
	0xf8, 0x83, 0xa9, 0x4f, 0x7d, 0xb2, 0x56, 0xad, 0xe5, 0x3f, 0xfb, 0xf0,
	0xf6, 0x09, 0xf1, 0x5b, 0x3c, 0x90, 0x58, 0x0e, 0x15, 0xc9, 0x68, 0xd9,
	0x30, 0x40, 0xfb, 0x82, 0x73, 0x98, 0x79, 0xbb, 0xcd, 0xb8, 0x27, 0xc3,
	0x8e, 0x6c, 0xff, 0xf6, 0x99, 0x26, 0xb0, 0xaf, 0xb0, 0xac, 0x33, 0xb3,
	0x50, 0xed, 0x73, 0xa1, 0xa8, 0x02, 0x38, 0xc6, 0x93, 0xf9, 0xd6, 0x17,
	0x7e, 0xbd, 0x97, 0xa4, 0xb5, 0x6f, 0x8a, 0xdb, 0x11, 0x78, 0x7c, 0x89,
	0x0e, 0x3c, 0x17, 0xbb, 0x54, 0x2c, 0x8d, 0x5a, 0x93, 0x7d, 0x1e, 0x33,
	0xc7, 0xd2, 0x7d, 0xe5, 0xaa, 0x12, 0x2d, 0xd9, 0x52, 0x4e, 0x63, 0x74,
	0xa6, 0x57, 0x9f, 0x1a, 0xd6, 0x3c, 0xc1, 0xb1, 0xab, 0x66, 0x4a, 0x0b,
	0x88, 0x1d, 0xa6, 0xd1, 0xbc, 0x60, 0x7a, 0x17, 0x1f, 0x8f, 0x9b, 0x35,
	0x57, 0xf8, 0xd0, 0x1c, 0xd3, 0xa6, 0x56, 0xc8, 0x03, 0x9c, 0x08, 0x3b,
	0x1b, 0x5b, 0xc2, 0x03, 0x3b, 0x3a, 0xa4, 0xe8, 0xed, 0x75, 0x66, 0xb0,
	0x85, 0x56, 0x40, 0xfe, 0xae, 0x97, 0x7e, 0xc0, 0x79, 0x49, 0x13, 0x8b,
	0x01, 0x0c, 0xae, 0x4c, 0x3d, 0x54, 0x47, 0xc5, 0x51, 0x40, 0x3d, 0xcc,
	0x4d, 0x17, 0xb3, 0x4e, 0x1d, 0x85, 0x1c, 0x41, 0x07, 0x03, 0x5e, 0xf9,
	0xfa, 0x17, 0x81, 0x24, 0x34, 0xaa, 0xbf, 0x67, 0x73, 0xb6, 0x9c, 0x67,
	0x36, 0xd9, 0xee, 0xf7, 0x86, 0x4c, 0x4d, 0x79, 0xca, 0xd7, 0xfd, 0x72,
	0xf9, 0xb3, 0x73, 0xc3, 0x57, 0xe5, 0x39, 0x72, 0x93, 0x56, 0xc2, 0xec,
	0xf8, 0x25, 0xe4, 0x8f, 0xba, 0xd0, 0x6f, 0x23, 0x8c, 0x39, 0x9e, 0x05,
	0x1a, 0x4e, 0xdc, 0x5e, 0xcd, 0x17, 0x59, 0x94, 0x37, 0x22, 0xb7, 0x39,
	0x50, 0x65, 0xdc, 0x91, 0x3c, 0xe1, 0x02, 0x81, 0x81, 0x00, 0xe4, 0xc6,
	0x42, 0xe5, 0xea, 0xe5, 0x32, 0xf3, 0x51, 0x36, 0x7b, 0x8c, 0x5b, 0x72,
	0x24, 0x1a, 0x4a, 0x44, 0x4f, 0x64, 0xe5, 0xa7, 0x74, 0xd9, 0xb2, 0x29,
	0x8a, 0x08, 0xcf, 0x9b, 0xd2, 0x9d, 0xc4, 0x20, 0x4c, 0xd3, 0x60, 0x4d,
	0xf7, 0xb7, 0xac, 0x92, 0x6b, 0x2b, 0x95, 0x73, 0x6e, 0x57, 0x00, 0x20,
	0x9d, 0xb2, 0xf6, 0xbd, 0x0b, 0xbb, 0xaa, 0x7e, 0x7e, 0x3e, 0x53, 0xfb,
	0x79, 0x7e, 0x45, 0xd5, 0x2e, 0xab, 0x5e, 0xff, 0x5c, 0x0a, 0x45, 0x2d,
	0x27, 0x19, 0xb0, 0x59, 0x0a, 0x39, 0x89, 0xf6, 0xae, 0xc6, 0xe2, 0xd1,
	0x07, 0x58, 0xbe, 0x95, 0x27, 0xaf, 0xf7, 0xa6, 0x2f, 0xaa, 0x37, 0x25,
	0x7c, 0x7b, 0xd3, 0xda, 0x13, 0x76, 0x0a, 0xb6, 0x6c, 0x99, 0x53, 0x5d,
	0xa5, 0x75, 0xfa, 0x10, 0x9b, 0x7f, 0xfe, 0xd7, 0xb4, 0x18, 0x95, 0xa8,
	0x65, 0x85, 0x07, 0xc5, 0xc4, 0xad, 0x02, 0x81, 0x81, 0x00, 0xc2, 0xb8,
	0x8e, 0xed, 0x9d, 0x4a, 0x1f, 0x9c, 0xda, 0x73, 0xf0, 0x2c, 0x35, 0x91,
	0xe4, 0x40, 0x78, 0xe1, 0x12, 0xf3, 0x08, 0xef, 0xdf, 0x97, 0xa0, 0xb0,
	0xdd, 0xea, 0xc2, 0xb9, 0x5b, 0xf8, 0xa1, 0xac, 0x32, 0xfd, 0xb8, 0xe9,
	0x0f, 0xed, 0xfd, 0xe0, 0xdc, 0x38, 0x90, 0x5e, 0xf5, 0x4c, 0x02, 0xc3,
	0x1a, 0x72, 0x18, 0xf7, 0xfe, 0xb7, 0xb8, 0x2a, 0xf8, 0x72, 0xbb, 0x99,
	0x56, 0xec, 0x85, 0x58, 0x31, 0x7e, 0x64, 0xdf, 0x02, 0x05, 0xe3, 0xb2,
	0xbb, 0xe2, 0x1b, 0xd6, 0x43, 0x73, 0xf8, 0x0f, 0xaf, 0x89, 0x57, 0x44,
	0x5f, 0x30, 0x1c, 0xe5, 0x78, 0xbf, 0x0b, 0xe7, 0x4b, 0xbe, 0x80, 0x2f,
	0x3d, 0x35, 0x44, 0xfc, 0x9e, 0x0d, 0x85, 0x5d, 0x94, 0x6e, 0xe9, 0x6a,
	0x72, 0xa7, 0x46, 0xd8, 0x64, 0x6c, 0xe9, 0x61, 0x92, 0xa0, 0xb6, 0xd1,
	0xee, 0xa6, 0xa6, 0xf4, 0x2c, 0x29, 0x02, 0x81, 0x81, 0x00, 0xb4, 0xa7,
	0x7b, 0x1c, 0x64, 0x29, 0x29, 0xda, 0xca, 0x3e, 0xe3, 0xc1, 0x2a, 0x55,
	0x2f, 0xfd, 0x32, 0xb8, 0x4e, 0x99, 0xb6, 0x60, 0x4d, 0xfd, 0xba, 0x9a,
	0xe2, 0xcd, 0xa2, 0x63, 0xc2, 0x25, 0xa3, 0x42, 0x7e, 0x68, 0x4c, 0x9c,
	0x45, 0x09, 0x5d, 0xd5, 0x21, 0x9c, 0x01, 0x20, 0x6d, 0xf9, 0x75, 0xb8,
	0x4b, 0xcf, 0x8e, 0xd8, 0x29, 0xf3, 0xbf, 0xe6, 0xb3, 0x7a, 0x34, 0x87,
	0x58, 0xa1, 0x46, 0x33, 0xd9, 0xee, 0xa9, 0xcd, 0xac, 0xb8, 0xcf, 0x77,
	0xa0, 0x70, 0xc0, 0xb9, 0x0f, 0x41, 0xf0, 0x98, 0x43, 0xdb, 0xfa, 0x30,
	0x66, 0x44, 0xc5, 0xfa, 0xb2, 0xa4, 0x5a, 0x43, 0x79, 0x50, 0x48, 0xcb,
	0xe9, 0x49, 0x3f, 0x39, 0xee, 0x34, 0x40, 0xb1, 0x5d, 0x80, 0x96, 0x3c,
	0x54, 0xf4, 0x9c, 0xcb, 0x90, 0x7f, 0xba, 0x96, 0x4b, 0x39, 0x3e, 0xb5,
	0x03, 0xb5, 0xd1, 0x35, 0x72, 0xe1, 0x02, 0x81, 0x80, 0x60, 0x14, 0xd5,
	0x61, 0xe6, 0x24, 0xf7, 0x28, 0x5c, 0x9a, 0xac, 0xbe, 0x03, 0xc8, 0xf3,
	0x49, 0xe4, 0xdb, 0x9a, 0x90, 0x15, 0xae, 0xd7, 0x33, 0x68, 0x75, 0x1d,
	0x6b, 0x83, 0x9e, 0x17, 0x05, 0xbe, 0x30, 0xcc, 0x10, 0x6a, 0x37, 0x86,
	0x46, 0xb6, 0xe9, 0x47, 0x81, 0x19, 0xab, 0xe1, 0x7a, 0x1a, 0x3a, 0xcf,
	0x47, 0xd1, 0x8e, 0x3d, 0x3f, 0xc6, 0x3e, 0x5d, 0xcd, 0xaf, 0x47, 0xe0,
	0x9e, 0x60, 0xc5, 0xbd, 0xd6, 0x52, 0x4b, 0xc0, 0x21, 0xcb, 0xd3, 0x1b,
	0xe6, 0x5c, 0x3a, 0x03, 0x9a, 0xab, 0xa2, 0x81, 0xc9, 0x51, 0x28, 0x49,
	0x97, 0xe2, 0x0a, 0x50, 0xe4, 0x64, 0x29, 0x43, 0x34, 0xc2, 0xe7, 0x8c,
	0x5a, 0x46, 0xaa, 0x28, 0x0b, 0x1f, 0xed, 0xa7, 0x1a, 0x7b, 0x4e, 0xad,
	0x38, 0x61, 0x3a, 0xd1, 0x82, 0xf4, 0x3d, 0xd3, 0x2e, 0x3e, 0x47, 0xa4,
	0x6c, 0xd3, 0x20, 0xd4, 0xd1, 0x02, 0x81, 0x80, 0x68, 0x1a, 0x8d, 0x3c,
	0x18, 0x3f, 0x42, 0x5e, 0x38, 0x6d, 0x0a, 0x1e, 0x52, 0xd5, 0x8f, 0xd6,
	0x32, 0xff, 0x7c, 0x1c, 0xf3, 0x20, 0x8b, 0x92, 0xa5, 0x44, 0xff, 0x08,
	0x21, 0xa1, 0xce, 0x68, 0x8b, 0x03, 0xe0, 0x90, 0xeb, 0x01, 0x4e, 0x85,
	0xf9, 0xc5, 0xb7, 0x86, 0xee, 0xd0, 0x59, 0x10, 0x73, 0x98, 0x2a, 0xcb,
	0xf6, 0xfe, 0x0d, 0xba, 0x07, 0x91, 0x18, 0xf6, 0xbc, 0x93, 0x8a, 0x91,
	0xdd, 0x80, 0x16, 0x37, 0xdf, 0x75, 0x46, 0x87, 0x68, 0xee, 0xf4, 0x76,
	0x0c, 0xc5, 0x87, 0x38, 0xf5, 0xb6, 0xda, 0x8a, 0xee, 0x62, 0xc8, 0xc0,
	0xa2, 0x8d, 0xbf, 0xd5, 0xf8, 0xba, 0xb5, 0x74, 0xf0, 0x07, 0xa6, 0x1c,
	0xcf, 0x76, 0x61, 0xbe, 0xa4, 0x88, 0x4a, 0x95, 0xb0, 0xa3, 0x70, 0x73,
	0xa1, 0x6f, 0x73, 0xf0, 0xe8, 0x38, 0x8d, 0xe8, 0xd0, 0x7e, 0x2c, 0x0c,
	0xdc, 0x21, 0xfa, 0xc1
};
const UINT server_cert_key_der_len = 1192;

static uint8_t nx_server_pool[NX_SERVER_POOL_SIZE]; //might need to be in no cache region
static NX_WEB_HTTP_SERVER_MIME_MAP my_mime_maps[] =
{
  {"css", "text/css"},
  {"svg", "image/svg+xml"},
  {"png", "image/png"},
  {"jpg", "image/jpg"},
  {"xml", "application/xml"}
};

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */
extern void _fx_ram_driver(FX_MEDIA *media_ptr);

static void App_Main_Thread_Entry(ULONG thread_input);
static void Unnamed_Thread_Entry(ULONG thread_input);
static VOID ip_address_change_notify_callback(NX_IP *ip_instance, VOID *ptr); // DHCP state change notify callback
static UINT webserver_request_notify_callback(NX_WEB_HTTP_SERVER *server_ptr, UINT request_type, CHAR *resource, NX_PACKET *packet_ptr); // Server callback when a new request from a client is triggered
static UINT webserver_authentication_callback(NX_WEB_HTTP_SERVER *server_ptr, UINT request_type, CHAR *resource, CHAR **name, CHAR **password, CHAR **realm);
static void NxGetPageName(char *resource,char *pn,u8 pnSz);

/* USER CODE END PFP */
/**
  * @brief  Application NetXDuo Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT MX_NetXDuo_Init(VOID *memory_ptr)
{
  UINT ret = NX_SUCCESS;
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;

  /* USER CODE BEGIN MX_NetXDuo_MEM_POOL */

  /* USER CODE END MX_NetXDuo_MEM_POOL */

  /* USER CODE BEGIN MX_NetXDuo_Init */
  //Avoid HAL and Thread calls in this function, wait for thread creation
  //byte_pool is the 'NetXDuo Memory Pool' defined in CubeMX
  printf("I:Nx_Webserver application started\n");
  printf("NX_PACKET_POOL_SIZE=%u,SERVER_POOL_SIZE=%u\n",NX_PACKET_POOL_SIZE,NX_SERVER_POOL_SIZE);

  // Initialize the NetXDuo system.
  nx_system_initialize();

  // Allocate the Ethernet packet pool.
  ret = tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, NX_PACKET_POOL_SIZE, TX_NO_WAIT);
  if (ret != NX_SUCCESS) // Check ethernet packet pool memory allocation.
  {
    printf("Packed pool memory allocation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Create a packet pool.
  ret = nx_packet_pool_create(&nx.EthPool, "NetX Main Packet Pool", NX_PACKET_PAYLOAD_SIZE, nx.pointer, NX_PACKET_POOL_SIZE);
  if (ret != NX_SUCCESS) // Check for packet pool creation status.
  {
    printf("Packed creation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Allocate the server packet pool.
  ret = tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, NX_SERVER_POOL_SIZE, TX_NO_WAIT);
  if (ret != NX_SUCCESS) // Check server packet pool memory allocation.
  {
    printf("Packed pool memory allocation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Create the server packet pool.
  ret = nx_packet_pool_create(&nx.WebServerPool, "HTTP Server Packet Pool", NX_SERVER_PACKET_SIZE, nx_server_pool, NX_SERVER_POOL_SIZE);
  if (ret != NX_SUCCESS) // Check for server pool creation status.
  {
    printf("Server pool creation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Allocate the NetX IP Instance memory.
  ret = tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, NX_MEMSIZE_IP_INSTANCE, TX_NO_WAIT);
  if (ret != NX_SUCCESS) // Check NetX IP Instance memory allocation.
  {
    printf("NetX IP Instance memory allocation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Create an IP instance by linking the nx_driver_St32h7xx driver
  ret = nx_ip_create(&nx.IpInstance, "NetX IP Instance 0", NX_NULL_IP_ADDRESS, NX_NULL_IP_ADDRESS, &nx.EthPool, nx_stm32_eth_driver,nx.pointer, NX_MEMSIZE_IP_INSTANCE, NX_HIGH_PRIO);
  if (ret != NX_SUCCESS)
  {
    printf("IP Instance creation failed : 0x%02x\n",ret);
    Error_Handler();
  }

  // Allocate the ARP cache.
  ret = tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, NX_ARP_CACHE_SIZE, TX_NO_WAIT);
  if (ret != NX_SUCCESS) // Check ARP cache memory allocation.
  {
    printf("ARP cache memory allocation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Enable ARP and supply ARP cache memory for IP Instance 0.
  ret =  nx_arp_enable(&nx.IpInstance, (void *) nx.pointer, NX_ARP_CACHE_SIZE);
  if (ret != NX_SUCCESS)
  {
    printf("ARP Enable for IP error : 0x%02x\n", ret);
    Error_Handler();
  }

   // Enable the ICMP support to be able to ping the board
  ret = nx_icmp_enable(&nx.IpInstance);
  if (ret != NX_SUCCESS)
  {
    printf("ICMP enable for IP error : 0x%02x\n", ret);
    Error_Handler();
  }

  // Enable UDP support needed  by DHCP client
  ret =  nx_udp_enable(&nx.IpInstance);
  if (ret != NX_SUCCESS)
  {
    printf("UDP enable for IP error : 0x%02x\n", ret);
    Error_Handler();
  }

  // Enable the TCP protocol
  ret =  nx_tcp_enable(&nx.IpInstance);
  if (ret!=NX_SUCCESS)
  {
    printf("TCP enable for IP error : 0x%02x\n", ret);
    Error_Handler();
  }

  // Allocate the server stack.
  ret = tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, MX_MEMSIZE_WEBSERVER_STACK, TX_NO_WAIT);
  if (ret != NX_SUCCESS) // Check server stack memory allocation.
  {
    printf("Server stack memory allocation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Create the HTTP Server.
  ret = nx_web_http_server_create(&nx.HTTPServer, "WEB HTTP Server", &nx.IpInstance, NX_CONNECTION_PORT ,&ram_disk, nx.pointer,MX_MEMSIZE_WEBSERVER_STACK, &nx.WebServerPool, webserver_authentication_callback, webserver_request_notify_callback);
  if (ret != NX_SUCCESS)
  {
     printf("HTTP Server creation failed: 0x%02x\n", ret);
     Error_Handler();
  }

  // Allocate the main thread.
  ret = tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, NX_MEMSIZE_MAIN_THREAD, TX_NO_WAIT);
  if (ret != NX_SUCCESS) // Check main thread memory allocation.
  {
    printf("Main thread memory allocation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  // Create the main thread
  ret = tx_thread_create(&nx.AppMainThread, "App Main thread", App_Main_Thread_Entry, 0, nx.pointer, NX_MEMSIZE_MAIN_THREAD,NX_MED_PRIO, NX_MED_PRIO, TX_NO_TIME_SLICE, TX_AUTO_START);
  if (ret != TX_SUCCESS)
  {
    return NX_NOT_ENABLED;
  }

    // Allocate the memory for unnamed thread
  if (tx_byte_allocate(byte_pool, (VOID **) &nx.pointer, NX_MEMSIZE_UNNAMED_THREAD, TX_NO_WAIT) != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }

  // create the unnamed thread
  ret = tx_thread_create(&nx.UnnamedThread, "Unnamed Thread", Unnamed_Thread_Entry, 0, nx.pointer, NX_MEMSIZE_UNNAMED_THREAD,NX_LOW_PRIO, NX_LOW_PRIO, TX_NO_TIME_SLICE, TX_DONT_START);
  if (ret != TX_SUCCESS)
  {
    return NX_NOT_ENABLED;
  }

  // Create the DHCP instance.
  ret = nx_dhcp_create(&nx.DHCPClient, &nx.IpInstance, "dhcp_client");
  if (ret != NX_SUCCESS)
  {
    printf("DHCP Instance creation failed : 0x%02x\n", ret);
  }

  ret = nx_ip_address_change_notify(&nx.IpInstance, ip_address_change_notify_callback, NULL);
  if (ret != NX_SUCCESS)
  {
    Error_Handler();
  }

  ret = tx_semaphore_create(&nx.Semaphore, "App Semaphore", 0);
  if (ret != TX_SUCCESS)
  {
    printf("Semaphore creation failed : 0x%02x\n", ret);
    Error_Handler();
  }

  /* USER CODE END MX_NetXDuo_Init */

  return ret;
}

/* USER CODE BEGIN 1 */

static VOID App_Main_Thread_Entry(ULONG thread_input)
{
	UINT ret;

	tx_thread_resume(&nx.UnnamedThread); //start unnamed thread

	ret = nx_dhcp_start(&nx.DHCPClient);
	if (ret != NX_SUCCESS)
	{
		Error_Handler();
	}

	/* wait until an IP address is ready */
	if(tx_semaphore_get(&nx.Semaphore, TX_WAIT_FOREVER) != TX_SUCCESS)
	{
		Error_Handler();
	}

	/* get IP address */
	ret = nx_ip_address_get(&nx.IpInstance, &nx.IpAddress, &nx.NetMask);

	printf("IP: %lu.%lu.%lu.%lu \n",(nx.IpAddress>>24)&0xff,(nx.IpAddress>>16)&0xff,(nx.IpAddress>>8)&0xff,nx.IpAddress&0xff);

	if (ret != TX_SUCCESS)
	{
		Error_Handler();
	}

	memset(&server_certificate, 0, sizeof(server_certificate));

	// the network is correctly initialized, start the WEB server
  //The TLS server needs an identity certificate which is imported as a binary DER-encoded X.509 certificate and its associated private key (e.g. DER-encoded PKCS#1 RSA private key).
	ret =  nx_secure_x509_certificate_initialize(&server_certificate, server_cert_der,server_cert_der_len, NX_NULL, 0,server_cert_key_der, server_cert_key_der_len,NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER);
  if (ret != NX_SUCCESS) // Check the WEB HTTP Server starting status.
  {
    printf("certificate initialize Failed, error: 0x%02x\n", ret);
    Error_Handler();
  }
  else
  {
    printf("certificate_initialize success\n");
  }

  //Setup TLS session data for the TCP server. This enables TLS and HTTPS for the server.
  ret = nx_web_http_server_secure_configure(&nx.HTTPServer, &nx_crypto_tls_ciphers,crypto_metadata, sizeof(crypto_metadata), server_tls_packet_buffer,sizeof(server_tls_packet_buffer), &server_certificate, NX_NULL, 0,NX_NULL, 0, NX_NULL, 0);
  if (ret != NX_SUCCESS) // Check the WEB HTTP Server starting status.
  {
    printf("secure configure Failed, error: 0x%02x\n", ret);
    Error_Handler();
  }
  else
  {
    printf("secure configure success\n");
  }

  ret = nx_web_http_server_mime_maps_additional_set(&nx.HTTPServer,&my_mime_maps[0], 5);
  ret = nx_web_http_server_start(&nx.HTTPServer); // Start the WEB HTTP Server.

  if (ret != NX_SUCCESS) // Check the WEB HTTP Server starting status.
  {
    printf("HTTP WEB Server Starting Failed, error: 0x%02x\n", ret);
    Error_Handler();
  }
  else
  {
    printf("HTTP WEB Server successfully started.\n");
  }

  while (1)
  {
    HAL_GPIO_TogglePin(GPO_LED_GREEN_GPIO_Port, GPO_LED_GREEN_Pin);
    tx_thread_sleep(100);
    nx.upTime++;
  }
}

static void Unnamed_Thread_Entry(ULONG thread_input)
{
  while (1)
  {
    HAL_GPIO_TogglePin(GPO_LED_YELLOW_GPIO_Port, GPO_LED_YELLOW_Pin);
    tx_thread_sleep(100);
  }
}

static VOID ip_address_change_notify_callback(NX_IP *ip_instance, VOID *ptr)
{
  tx_semaphore_put(&nx.Semaphore);
  printf("S:ip_address_change_notify_callback\r\n");
}

static UINT webserver_request_notify_callback(NX_WEB_HTTP_SERVER *server_ptr, UINT request_type, CHAR *resource, NX_PACKET *packet_ptr)
{
	const u32 sbSz=4096;
	NX_PACKET *resp_packet_ptr;
	char *pc1,*pc2;
	ULONG //hLen, //header length
			  sbLen, //session buffer length
				varu32_1,varu32_2;
	UINT status,
	     varuint_1; //return status
	bool pf; //page found
	const u8 pnSz=16;
	char pn[pnSz]; //page name
  CHAR rType[30], //resource type
   	 	 sb[sbSz]; //data buffer to output

  pf=false;
  sbLen=0;
  rType[0]=sb[0]=0;
  nx_web_http_server_type_get(server_ptr, server_ptr -> nx_web_http_server_request_resource, rType, &status); // Derive the client request type from the client request.
  rType[status] = '\0'; // Null terminate the string.

  if(resource[0]=='\0'||strncmp(resource,"/\0",2)==0) //redirect off website base
  {
  	sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,
  		"%s\r\n"
  		"Location: index.html\r\n"
  	  ,rType
  	);

    status = nx_web_http_server_callback_generate_response_header(server_ptr, &resp_packet_ptr, NX_WEB_HTTP_STATUS_MOVED_PERMANETLY,0, sb, NX_NULL);
    status = nx_web_http_server_callback_packet_send(server_ptr, resp_packet_ptr); // send the packet
    if (status != NX_SUCCESS)
    {
      nx_packet_release(resp_packet_ptr);
      return status;
    }
  }
  else
  {
		if(resource[0]=='/')
		{
			NxGetPageName(resource,pn,pnSz);
			if(resource[1]=='c')
			{
				if(strcmp(resource,"/common.js")==0)
				{
					pf=true;
					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,"%s",
						"var cGIN=false;" //ignore next
						"var cGCTO=false;" //clear timeout
						"var cGSTO;" //set timeout
						"function C1(){"
							"console.log('hi');"
						"}" //Common Update Ajax v1:url,v2:callBack,v3:repeat
						"function CUA(v1,v2,v3){"
							"var xhr,xml;"
							"xhr=new XMLHttpRequest();"
							"xhr.open('GET',v1, true);"
							"xhr.timeout=60000;"
							"xhr.ontimeout=function(e){"
								"console.log(\"xhr timeout\");"
								"CCL();"
							"};"
							"xhr.onload=function(){"
								"if(this.status==200){" //if received a reply successfully
									"if(cGCTO==true){"
										"cGCTO=false;"
									"}"
									"else{"
										"if(v3){"
											"cGSTO=setTimeout(function(){CUA(v1,v2,true);},1000);"
										"}"
									"}"
									"if(xhr.responseXML==null)return 0;"
									"if(cGIN){"
										"cGIN=false;"
									"}"
									"else{"
										"CPR(xhr.responseXML);"
										"if(v2!=undefined){"
											"v2();"
										"}"
									"}"
								"}"
								"else{"
									"if(this.status==401)console.log(\"xhr reply fail 401: Unauthorized\");"
									"else if(this.status==403)console.log(\"xhr reply fail 403: Forbidden\");"
									"else if(this.status==404)console.log(\"xhr reply fail 404: URL not found\");"
									"else console.log(\"xhr reply fail\" + this.status + \": Unknown error\");"
									"CCL();"
								"}"
							"};"
							"xhr.onerror=function(){"
								"console.log(\"xhr error\");"
								"CCL();"
							"};"
							"xhr.send(null);"
						"}"	//connection lost
						"function CCL(){"
							"document.getElementsByTagName('body')[0].innerHTML='Connection Lost';"
						"}" //Process Response v1=xmlDoc, CEMCB=Common Element Miss Callback
						"function CPR(v1){"
							"var i,l1,l2,l3,l4,l5;" //l1=elId,l2=elValue,l3=textElementArr,l4=circElementArr,l5=elFill
							"l3=v1.getElementsByTagName('text');"
							"for(i=0;i<l3.length;i++){"
								"l1=l3[i].childNodes[0].childNodes[0].nodeValue;"
								"l2=l3[i].childNodes[1].childNodes[0].nodeValue;"
								"if(document.getElementById(l1)){"
									"if(document.getElementById(l1).nodeName=='INPUT')document.getElementById(l1).value=l2;"
									"else"
									"{"
										"if(l2>3275&&l2<3280){"
											"document.getElementById(l1).innerHTML=\"\";"
										"}"
										"else{"
											"document.getElementById(l1).innerHTML=l2;"
										"}"
									"}"
								"}"
								"else{"
									"if(typeof CEMCB==='function')CEMCB();"
									"console.log('xhr text l1='+l1+',value='+l2);"
								"}"
							"}"
							"l4=v1.getElementsByTagName('circ');"
							"for(i=0;i<l4.length;i++){"
								"l1=l4[i].childNodes[0].childNodes[0].nodeValue;"
								"l5=l4[i].childNodes[1].childNodes[0].nodeValue;"
								"if(document.getElementById(l1)){"
									"document.getElementById(l1).style.fill=l5;"
								"}"
								"else{"
									"if(typeof CEMCB==='function')CEMCB();"
									"console.log('xhr circ l1='+l1+'value='+l5);"
								"}"
							"}"
						"}"  //XHR Boiler 1.url,2.outstr,3.msgElem,4.showSuccess,5.callbackSuccess,6.showFail,7.callbackFail,8.showUpdating,9.reloadOnResult
						"function CXHRB(v1,v2,v3,v4,v5,v6,v7,v8,v9){"
							"var xhr;"
							"if(v3&&v8==true){"
								"v3.innerHTML=\"Updating\";"
								"v3.style.backgroundColor=\"gold\";"
							"}"
							"xhr=new XMLHttpRequest();"
							"xhr.open('post',v1,true);"
							"xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");"
							"xhr.timeout=30000;"
							"xhr.ontimeout=function(e){"
								"console.log(\"xhr ontimeout\");"
								"CXHRE(v3,v6,v7);"
							"};"
							"xhr.onload=function(){"
								"if(this.status==200){" //if received a reply successfully
									"if(v4==true){"
										"if(v3){"
											"v3.innerHTML=\"Success\";"
											"v3.style.backgroundColor=\"limegreen\";"
										"}"
									"}"
									"if(v5&&v5!=undefined){"
										"v5(xhr.response);"
									"}"
									"if(v9){"
										"location.href=location.href;"
									"}"
								"}"
								"else{"
									"console.log(\"xhr onload fail status = \"+this.status);"
									"CXHRE(v3,v6,v7);"
								"}"
							"};"
							"xhr.onerror=function(){"
								"console.log(\"xhr onerror\");"
								"CXHRE(v3,v6,v7);"
							"};"
							"xhr.send(v2);"
						"}" //XHRERROR msgElem,showFail,callbackFail
						"function CXHRE(v1,v2,v3){"
							"if(v1&&v2){"
								"v1.innerHTML=\"Error: Check comms with EWS\";"
								"v1.style.backgroundColor=\"crimson\";"
							"}"
							"if(v3&&v3!=undefined)v3();"
						"}"
					);
				}
			}
			else if(resource[1]=='i')
			{
				if(strcmp(resource,"/index.html")==0)
				{
					pf=true;

					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,NX_STR_HEADER_1
					,"Page Title"
					,pn
					);

					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,
							"</HEAD>"
							"<BODY onLoad='OL();'>"
								"<H1>Dashboard</H1>"
								"<p>Resource Type: %s</p>"
							  "<p>Size Of Unsigned Int: %u</p>"
								"<script>C1();</script>"
							  "<p>Uptime: <input id='i1' value=''></p>"
							  "<p>"
							    "Set Uptime: <input id='i2' value=''>"
							    "<input type='button' value='set' onclick=\"CXHRB('post.html','i2='+document.getElementById('i2').value);\""
							  "</p>"
							"</BODY>"
						"</HTML>"
					,rType
					,sizeof(UINT)
					);
				}
				else if(strcmp(resource,"/index.js")==0)
				{
					pf=true;
					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,"%s",
					  "function OL(){"
							"console.log('OL');"
					    "cGSTO=setTimeout(function(){CUA('index.xml',OU,true);},1000);"
						"}"
						"function OU(){"
							"console.log('OU');"
						"}"
					);
				}
				else if(strcmp(resource,"/index.xml")==0)
				{
					pf=true;
					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,
						"<?xml version='1.0' encoding='UTF-8'?>"
					  "<form>"
							"<text><id>%s</id><value>%u</value></text>"
						"</form>"
						,"i1"
						,nx.upTime
					);
				}
			}
			else if(resource[1]=='l')
			{
				if(strcmp(resource,"/logoff.html")==0)
				{
					pf=true;
					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,"%s",
						"<HTML>"
							"<HEAD><TITLE>NetX HTTP</TITLE></HEAD>"
							"<BODY>"
									"<H1>Logoff Page</H1>"
							"</BODY>"
						"</HTML>"
					);
				}
			}
			else if(resource[1]=='p')
			{
				if(strcmp(resource,"/post.html")==0)
				{

					/*
						ULONG status = NX_SUCCESS;
						ULONG contentLen, remainingLen;
						UINT copiedLen = 0, receivedLen = 0;
						CHAR *receive_buffer;

						contentLen = (ULONG)nx_http_server_content_length_get(packet_ptr);
						remainingLen = contentLen;

						if(contentLen && ((receive_buffer = malloc(contentLen + 1)) != NULL)) // + 1 for NULL-termination of string
						{
								*(receive_buffer + contentLen) = 0;
								while(remainingLen && (status == NX_SUCCESS))
								{
										if((status = nx_http_server_content_get(server_ptr, packet_ptr, receivedLen, receive_buffer + receivedLen, remainingLen, &copiedLen)) == NX_SUCCESS)
										{
												receivedLen += copiedLen;
												remainingLen -= copiedLen;
										}
								}
								if(receivedLen == contentLen) // all bytes received
								{
										// work with the received data here
								}
								free(receive_buffer);
						}
					 */

					pf = true;
					status = nx_web_http_server_content_length_get(packet_ptr,&varu32_1);
					varuint_1=varu32_1;
					status = _nxe_web_http_server_content_get(server_ptr, packet_ptr, 0, sb, sbSz, &varuint_1);

					pc1=sb; //pointer to start of variable
					varu32_1=0; //start index
					if(varuint_1>0&&sb[0]!='&')
					{
						for(u32 i=0;i<varuint_1;i++)
						{
							if(sb[i]=='&'||i==varuint_1-1)
							{
								varu32_2=i-varu32_1; //varu32_2 is the length of the posted variable
								if(sb[i]!='&'&&i==varuint_1-1) varu32_2++; //add 1 to length if the last variable and no trailing &
								if(pc1[0]=='a')
								{


								}
								else if(pc1[0]=='i')
								{
								  if(pc1[1]=='2')
								  {
								  	if(pc1[2]=='=')
								  	{
								  		nx.upTime=strtoul(&pc1[3],&pc2,10);
								  	}
								  }
								}
								else if(pc1[0]=='z')
								{

								}

								//reset the start index for next loop
								varu32_1=i+1;
								pc1=&sb[i+1];
							}
						}
					}

					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,"%s",
						"OK"
					);
				}
			}
			else if(resource[1]=='t')
			{
				if(strcmp(resource,"/test.html")==0)
				{
					pf=true;
					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,
						"<HTML>"
							"<HEAD><TITLE>NetX HTTP</TITLE></HEAD>"
							"<BODY>"
									"<H1>Test Page</H1>"
									"%s"
							"</BODY>"
						"</HTML>"
					,rType
					);
				}
			}
			else if(resource[1]=='s')
			{
				if(strcmp(resource,"/styles.css")==0)
				{
					pf=true;
					sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,"%s",
						"@charset \"utf-8\";"
						"@import url('https://fonts.googleapis.com/css?family=Roboto:400,700');"
						"html,body,div,span,select,input,iframe,h1,h2,h3,h4,p,a,img,strong,b,u,i,ol,ul,li,form,label,table,tr,th,td,article,canvas,footer,header,nav{"
							"margin:0;"
							"padding:0;"
							"font-size:13px;"
							"font-family:\"Roboto\",Arial,sans-serif;"
						"}"
					);
				}
			}
		}

		if(pf==false) //page not found
		{

			sbLen+=snprintf(&sb[sbLen],(sbSz>sbLen)?sbSz-sbLen:0,"%s",
				"<HTML>"
					"<HEAD><TITLE>NetX HTTP</TITLE></HEAD>"
					"<BODY>"
							"<H1>Page Not Found</H1>"
					"</BODY>"
				"</HTML>"
			);
		}

		status = nx_web_http_server_callback_generate_response_header(server_ptr, &resp_packet_ptr, NX_WEB_HTTP_STATUS_OK,sbLen, rType, NX_NULL);
		status = _nxe_packet_data_append(resp_packet_ptr, sb, sbLen, server_ptr->nx_web_http_server_packet_pool_ptr, NX_WAIT_FOREVER);

		status = nx_web_http_server_callback_packet_send(server_ptr, resp_packet_ptr); // send the packet
		if (status != NX_SUCCESS)
		{
			nx_packet_release(resp_packet_ptr);
			return status;
		}


		//varu32_1=server_ptr->nx_web_http_server_allocation_errors;
		//status = nx_web_http_server_callback_generate_response_header(server_ptr, &resp_packet_ptr, NX_WEB_HTTP_STATUS_OK,sbLen, rType, NX_NULL);
		//if(server_ptr->nx_web_http_server_allocation_errors==varu31_1) //a packet was allocated
		//{
		//	_nxe_packet_length_get(resp_packet_ptr, &hLen); //gets the header length
		//
		//	if(hLen+sbLen>NX_PACKET_PAYLOAD_SIZE)
		//	{
		//
		//	}
		//	else //less than 1 packet
		//	{
		//
		//	}
		//	status = _nxe_packet_data_append(resp_packet_ptr, sb, sbLen, server_ptr->nx_web_http_server_packet_pool_ptr, NX_WAIT_FOREVER);
		//  status = nx_web_http_server_callback_packet_send(server_ptr, resp_packet_ptr); // send the packet
		//  if (status != NX_SUCCESS)
		//  {
		//    nx_packet_release(resp_packet_ptr);
		//    return status;
		//  }
		//}


  }

  return(NX_WEB_HTTP_CALLBACK_COMPLETED);
}

static UINT webserver_authentication_callback(NX_WEB_HTTP_SERVER *server_ptr, UINT request_type, CHAR *resource, CHAR **name, CHAR **password, CHAR **realm)
{
	*name =     "admin";
	*password = "password";
	*realm =    "NetX Duo HTTP demo";

	if(strcmp(resource,"/index.html")==0||
		 strcmp(resource,"/post.html")==0)
	{
		return(NX_WEB_HTTP_BASIC_AUTHENTICATE);
	}

  return(NX_WEB_HTTP_DONT_AUTHENTICATE);
}

static void NxGetPageName(char *resource,char *pn,u8 pnSz)
{
	for(u8 i=0;i<pnSz;i++)
	{
		if(resource[i]=='.')
		{
			break;
		}
		else
		{
			pn[i]=resource[i];
		}
	}
}


/* USER CODE END 1 */
